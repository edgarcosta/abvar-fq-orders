from deform import deform_middle_ordinary_squarefree
from utils import hw, poly_to_tuple, make_weil
from exhaust_small import seed_small
from time import time

from sage.all import (
    RealSet,
    floor,
    log,
    prime_divisors,
    cartesian_product,
)


from constructions import construction_hat_deform, construction_logexp_then_exhaust_deform

def cover_from_above(q, end, start=2):
    r"""
    Try to cover the interval [start, end] with intevals generated by
     - construction_deformhat(q, m, n)
     - construction_logexp_then_exhaust_deform(q, m, n)
    until both fail, where m is the largest integer in the interval [1, end] not yet covered,
    and n in floor(log(m)/log(q)) + {1, 0}.

    Returns:
    - a dictionary: (l, u + 1) -> (m, S, r, mu_ord, construction)
    - M the first integer that we encountered such that construction_deformhat(q, m)

    construction in {'hat', 'logexp', 'exhaust'}
    if construction == hat, len(S) = 1 and mu_ord > 0
    if construction != 'hat', len(S) = 2, r = 1, and mu_ord = 0
    each polynomial in the set S is represented by the leading n+1 coefficients of the polynomial of degree 2n
    """
    res = {}
    m = end
    while m >= start:
        n = floor(log(m)/log(q))
        for method, shift in cartesian_product([[construction_hat_deform, construction_logexp_then_exhaust_deform],
                                                [1,0]]):
            if n + shift > 1:
                out = method(q, m, n + shift)
                if out is not None:
                    break
        else:
            break # both methods failed
        interval, S, r, mu_ord, method = out
        assert all(h(1) == m for h in S)
        tupleS = tuple(poly_to_tuple(h) for h in S)
        l, u = interval
        res[(l, u + 1)] = (m, tupleS, r, mu_ord, method)
        m = l -1
    return res, m





def cover_from_below(q, end, res=dict(), n=None):
    if n is None:
        if q <= 3:
            n = 2
        elif q == 4:
            n = 3
        else:
            n = 4
    res[(1,2)] = (1, ((1,),), 0, 0, 'small')
    D = seed_small(q, n)
    p = prime_divisors(q)[0]
    miss = []
    nonord = []
    nonsf = []
    m = end
    while m > 1:
        if m not in D:
            miss.append(m)
            m -= 1
            continue
        S = [make_weil(q, g).reverse() for g in D[m]]
        Sord = [g for g in S if g[g.degree()//2] % p != 0]
        Ssf = [g for g in S if g.is_squarefree()]
        if Sord and Ssf and len(Ssf) > 1: # there is hope to cover more than just m
            out = deform_middle_ordinary_squarefree(q, Ssf)
            if out is not None: # cover more than m
                (l, u), hs = out
                res[(l, u + 1)] = m, [poly_to_tuple(elt) for elt in hs], 1, 0, 'small'
                m = l-1 # the next integer not covered
                continue
        if not Sord:
            nonord.append(m)
        if not Ssf:
            nonsf.append(m)
        # take the first polynomial
        res[(m, m + 1)] = m, [list(D[m])[0],], 0, 0, 'small'
        m -= 1
    miss.sort()
    nonord.sort()
    nonsf.sort()
    return res, miss, nonord, nonsf

def cover(q, end, start=2, filename=None):
    start_time = time()
    res, M = cover_from_above(q, end, start=start)
    if M < start:
        miss = nonord = nonsf = []
    else:
        # this updates res
        res, miss, nonord, nonsf = cover_from_below(q, M + 1, res=res)

    wall_time = time() - start_time
    if filename:
        write(filename, q, res, miss, nonord, nonsf, wall_time)
    return res, miss, nonord, nonsf, wall_time

def write(filename, q, res, miss, nonord, nonsf, wall_time):
    assert filename.endswith('txt')
    assert isinstance(res, dict)
    assert all(isinstance(elt, list) for elt in [miss, nonord, nonsf])
    if q <= 3:
        nsmall = 2
    elif q == 4:
        nsmall = 3
    elif q < 8:
        nsmall = 4
    else:
        nsmall = None
    coverage = sum((RealSet.closed_open(l,u) for (l, u) in res), RealSet())
    maxm = coverage.get_interval(coverage.n_components() - 1).upper()
    minm = coverage.get_interval(coverage.n_components() - 1).lower()
    if nsmall:
        minhwnext = hw(q, nsmall + 1).get_interval(0).lower()
        nonord_proven = [m for m in nonord if m < minhwnext]
        nonord_unproven = [m for m in nonord if m >= minhwnext]
        nonsf_proven = [m for m in nonsf if m < minhwnext]
        nonsf_unproven = [m for m in nonsf if m >= minhwnext]

    else:
        nonord_proven = []
        nonord_unproven = nonord
        nonsf_proven = []
        nonsf_unproven = nonsf
    with open(filename, 'w') as W:
        W.write('# q = %d\n' % q)
        W.write('# Integers covered = %s\n' % coverage)
        if minm > 1000:
            W.write('# %d ~ %d^%.2f\n' % (minm, q, log(minm, q)))
        W.write('# %d ~ %d^%.2f\n' % (maxm, q, log(maxm, q)))
        if nonord or nonsf:
            if nsmall:
                W.write('# exhaustive for g <= %d\n' % (nsmall,))
            if nonord_proven:
                W.write('# orders not realizable with ordinary AV = %s\n' % (nonord_proven,))
            if nonord_unproven:
                W.write('# orders potentially not realizable with ordinary AV = %s\n' % (nonord_unproven,))
            if nonsf_proven:
                W.write('# orders not realizable with a squarefree AV = %s\n' % (nonsf_proven,))
            if nonsf_unproven:
                W.write('# orders potentially not realizable with a squarefree AV = %s\n' % (nonsf_unproven,))
        else:
            if not nonord:
                W.write('# every order is realizable with ordinary AV\n')
            if not nonsf:
                W.write('# every order is realizable with squarefree AV\n')

        W.write('# total wall time = %.2f seconds\n' % (wall_time,))
        W.write("""#
# Each line has the following format:
# a:b:c:pol:r:mu_ord_lower:construction
# where:
# - a, b, c, r are integers
# - pol is a list of lists of integers, each list represents a monic Weil polynomial of degree 2n given by their n+1 leading coefficients,
# - mu_ord_lower is a real number
# - construction is a string in {'hat', 'logexp', 'exhaust', 'small'}
#
# For each (monic) Weil polynomial h(x) represented by pol we have h(1) = c.
# For construction is {logexp', 'exhaust', 'small'} we have mu_ord_lower = 0 and mu_ord_lower doesn't play a role.
#
# There are four cases, depending on the string construction:
# - 'hat'
# In this case, the row represents the output of Construction 9.5.
# Precisely, the list poly only represents one polynomial h(x) obtained via Construction 9.1,
# and the nth-coefficient of h is coprime to p.
# Let S_h be the set of integral polynomials obtained by integrally modifying
# the coefficients x^n, ..., x^(n + (r-1)) by at most floor(q/2) of h(x), and
# the lower coefficients accordingly to keep the q-symmetry.
# One can then realize every integer in [a, b) as f(1) with f in S_h.
# mu_ord_lower is a lower bound for mu_ord as defined in Section 9.
#
# - 'logexp'
# In this case, r=1, and poly  represents two Weil polynomials h0(x) and h1(x), such that
# (a) h0^[n] != h1^[n] mod p, and thus every number in [a, b) may be represented by an order of
# a squarefree ordinary abelian variety.
# (b) {h0, h1} < {g, g^+, g^-}, where g(x) = hat(h(x)) where h(x) is the polynomial
# produced by Construction 9.1 Steps 1-5, and g^+/- =  g(x) +/- (qx^{n-1} - (q+1)x^n + x^{n+1}).
# Furthermore, mu_ord_lower = 0 and mu_ord_lower doesn't play a role.
#
# - 'exhaust'
# As in 'logexp', but condition (b) is replaced with:
# (b') h0 and h1 have the same (n-1) leading coefficients as hat(h(x))
#
# - 'small'
# In this case the polynomials were generated from exhaustive search in low dimension.
# If the length of poly is 2, then condition (a) from 'logexp' holds and the polynomials were generated from exhaustive search in low dimension.
# If the length of poly is 1, ordinariness or squarefreeness might fail.
#
""")
        for a, b in sorted(res):
            c, hs, r, mu, cons = res[(a,b)]
            W.write(":".join(map(str, [a, b, c, list(map(list,hs)), r, mu, cons])) + '\n')
